---
layout: post
title: 曾经经历的面试题汇总（1）
date: 2015-04-02
categories: 面试题
tags: [面试题]
description: 面试题
comments: true
---

* content
{:toc}

记录经历过的Java 面试题








>1.多线程的几个状态？以及何时处于这个状态。？
	
　　链接：[java线程的几个概念和方法](http://www.blogjava.net/syniii/articles/338254.html)
　　
　　**开始（创建）**：在生成线程对象，并没有调用该对象的start方法，这是线程处于创建状态。

　　**就绪**：当调用了线程对象的start方法之后，该线程就进入了就绪状态，但是此时线程调度程序还没有把该线程设置为当前线程，此时处于就绪状态。在线程运行之后，从等待或者睡眠中回来之后，也会处于就绪状态。

　　**运行**：线程调度程序将处于就绪状态的线程设置为当前线程，此时线程就进入了运行状态，开始运行run函数当中的代码。

　　**阻塞**： 线程正在运行的时候，被暂停，通常是为了等待某个时间的发生(比如说某项资源就绪)之后再继续运行。sleep,suspend，wait等方法都可以导致线程阻塞。

　　**结束**：如果一个线程的run方法执行结束或者调用stop方法后，该线程就会死亡。对于已经死亡的线程，无法再使用start方法令其进入就绪。

>2.事件处理机制的实现原理。
	
　　**步骤：**

- 1．  新建一个组件（如jbutton）。 

- 2．  将该组件添加到相应的面板（如jpanel）。 

- 3．  注册监听器以监听事件源产生的事件（如通过actionlistener来响应用户点击按钮）。 

- 4．  定义处理事件的方法（如在actionlistener中的actionperformed中定义相应方法）。 
	
>3.观察者模式的作用。

　　Observer模式是行为模式之一，它的作用是当一个对象的状态发生变化时，能够自动通知其他关联对象，自动刷新对象状态。
4.jsp的内置对象。

　　第一类：与Servlet有关：page和config

　　第二类：与Input/Output有关：out，request和response

　　第三类：与Context有关：application，session和pageContext

　　第四类：与Error有关：exception

>5.ajax的实现了什么。

- 局部刷新。

- 优点：提高用户体验度。

- 基于js和xml。Asynchronous(异步的) JavaScript and XML

>6.数据库事务处理机制的作用。

　　数据库事务机制事务是这样一种机制,它确保多个SQL语句被当作单个工作单元来处理。事务具有以下的作用: 1.一致性:同时进行的查询和更新彼此不会发生冲突,其他用户不会　　看到发生了变化但尚未提交的数据。 2.可恢复性:一旦系统故障,数据库会自动地完全恢复未完成的事务。

>7.查询语句的实现需要注意什么。

　　书写简单SQL语句需要注意的问题[提高效率的查询]
　　摘自：百度知道：请简单说明SQL语句书可以提高执行效率的5种需要注意的书写方法

- 1、操作符号： NOT IN操作符 
- 2、注意union和union all的区别。union比union all多做了一步distinct操作。能用union all的情况下尽量不用union。 
- 3、查询时尽量不要返回不需要的行、列。另外在多表连接查询时，尽量改成连接查询，少用子查询。。 
- 4、尽量少用视图，它的效率低。
- 5、创建合理的索引，对于插入或者修改比较频繁的表，尽量慎用索引。因为如果表中存在索引，插入和修改时也会引起全表扫描。 
　　　　索引一般使用于where后经常用作条件的字段上。 
- 6、在表中定义字段或者存储过程、函数中定义参数时，将参数的大小设置为合适即可，勿设置太大。这样开销很大。 
- 7、Between在某些时候比IN速度更快,Between能够更快地根据索引找到范围。用查询优化器可见到差别。select * from chineseresume where title in ('男','女') Select * from chineseresume where between '男' and '女'是一样的。由于in会在比较多次，所以有时会慢些。 
- 8、在必要是对全局或者局部临时表创建索引，有时能够提高速度，但不是一定会这样，因为索引也耗费大量的资源。他的创建同是实际表一样。 
- 9、WHERE后面的条件顺序影响 WHERE子句后面的条件顺序对大数据量表的查询会产生直接的影响，如 Select * from zl_yhjbqk where dy_dj = '1KV以下' and xh_bz=1 Select * from zl_yhjbqk where xh_bz=1 and dy_dj = '1KV以下' 
以上两个SQL中dy_dj（电压等级）及xh_bz（销户标志）两个字段都没进行索引，所以执行的时候都是全表扫描，如果dy_dj ='1KV以下'条件在记录集内比率为99%，而xh_bz=1的比率只为0.5%，在进行第一条SQL的时候99%条记录都进行dy_dj及xh_bz的比较，而在进行第二条SQL的时候0.5%条记录都进行dy_dj及xh_bz的比较，以此可以得出第二条SQL的CPU占用率明显比第一条低。所以尽量将范围小的条件放在前面。。 

- 10、用OR的字句可以分解成多个查询，并且通过UNION 连接多个查询。他们的速度只同是否使用索引有关,如果查询需要用到联合索引，用 UNION all执行的效率更高.多个OR的字句没有用到索引，改写成UNION的形式再试图与索引匹配。一个关键的问题是否用到索引。 

- 11、没有必要时不要用DISTINCT和ORDER BY，这些动作可以改在客户端执行。它们增加了额外的开销。这同UNION和UNION ALL一样的道理。 

- 12、使用in时，在IN后面值的列表中，将出现最频繁的值放在最前面，出现得最少的放在最后面，这样可以减少判断的次数 

- 13、当用SELECT INTO时，它会锁住系统表(sysobjects，sysindexes等等)，阻塞其他的连接的存取。创建临时表时用显示声明语句，在另一个连接中SELECT * from sysobjects可以看到 SELECT INTO 会锁住系统表， Create table 也会锁系统表(不管是临时表还是系统表)。所以千万不要在事物内使用它！！！这样的话如果是经常要用的临时表请使用实表，或者临时表变量。 

- 14、一般在GROUP BY和HAVING字句之前就能剔除多余的行，所以尽量不要用它们来做剔除行的工作。他们的执行顺序应该如下最优：select 的Where字句选择所有合适的行，Group By用来分组个统计行，Having字句用来剔除多余的分组。这样Group By和Having的开销小，查询快.对于大的数据行进行分组和Having十分消耗资源。如果Group BY的目的不包括计算，只是分组，那么用Distinct更快. 

- 15、一次更新多条记录比分多次更新每次一条快,就是说批处理好 

- 16、慎用临时表，临时表存储于tempdb库中，操作临时表时，会引起跨库操作。尽量用结果集和表变量来代替它。 

- 17、尽量将数据的处理工作放在服务器上，减少网络的开销，如使用存储过程。存储过程是编译好、优化过，并且被组织到一个执行规划里、且存储在数据库中的 SQL语句，是控制流语言的集合，速度当然快。 

- 18、不要在一段SQL或者存储过程中多次使用相同的函数或相同的查询语句，这样比较浪费资源,建议将结果放在变量里再调用。这样更快。 

- 19、按照一定的次序来访问你的表。如果你先锁住表A，再锁住表B，那么在所有的存储过程中都要按照这个顺序来锁定它们。如果你（不经意的）某个存储过程中先锁定表B，再锁定表A,这可能就会导致一个死锁。如果锁定顺序没有被预先详细的设计好，死锁很难被发现

> 8.面向对象编程思想实现什么。

　　分离对象，更容易扩展等



> 9.ArrayList和数组的关系。

　　链接：数组与ArrayList的关系与区别
　　数组与ArrayList的主要区别：效率、类型识别和primitive type。

-  1.数组（[]）：最高效；但是其容量固定且无法动态改变；
　　ArrayList：容量可动态增长；但牺牲效率；
　　建议：
　　首先使用数组，无法确定数组大小时才使用ArrayList！

- 2.ArrayList存入对象时，抛弃类型信息，所有对象屏蔽为Object，编译时不检查类型，但是运行时会报错。

- 3.ArrayList可以存任何Object，如String，Employee等，但不支持基本数据类型，除非使用wrapper。

 